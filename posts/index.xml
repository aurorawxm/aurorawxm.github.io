<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on AuroraWxm</title>
    <link>https://aurorawxm.github.io/posts/</link>
    <description>Recent content in Posts on AuroraWxm</description>
    <image>
      <title>AuroraWxm</title>
      <url>https://aurorawxm.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://aurorawxm.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 13 May 2023 02:17:54 +0000</lastBuildDate><atom:link href="https://aurorawxm.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vue3.3 正式发布！</title>
      <link>https://aurorawxm.github.io/posts/vue3.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</link>
      <pubDate>Sat, 13 May 2023 02:17:54 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/vue3.3-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/</guid>
      <description>请注意，对复杂类型支持是基于 AST 的，因此不是 100% 全面的。一些需要实际类型分析的复杂类型，例如条件类型，不受支持。您可以使用条件类型来定义单个 prop 的类型，但不能用于整个 props 对象。
详情： PR#8083
泛型组件 使用 的组件现在可以通过 generic 属性接受泛型类型参数： HTML defineProps&amp;lt;{ items: T[] selected: T }&amp;gt;() generic 的值与 TypeScript 中 &amp;lt;&amp;hellip;&amp;gt; 之间的参数列表用法完全相同。例如，您可以使用多个参数、extend 约束、默认类型和引用导入的类型： html import type { Item } from &amp;lsquo;./types&amp;rsquo; defineProps&amp;lt;{ id: T list: U[] }&amp;gt;() 此功能在最新版本的 volar / vue-tsc 中默认启用。
相关讨论： RFC#436 相关 PR： generic defineComponent() - PR#7963
defineEmits 以前，defineEmits 的类型参数仅支持调用签名语法： js// 以前 const emit = defineEmits&amp;lt;{ (e: &amp;lsquo;foo&amp;rsquo;, id: number): void (e: &amp;lsquo;bar&amp;rsquo;, name: string, &amp;hellip;rest: any[]): void }&amp;gt;()</description>
    </item>
    
    <item>
      <title>Vue3&#43;TS 使用指南</title>
      <link>https://aurorawxm.github.io/posts/vue3&#43;ts-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 12 May 2023 03:03:06 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/vue3&#43;ts-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>vue3相比vue2对ts拥有更友好的支持，当初在用vue2写ts时各种装饰器，现在只要使用标签就可以直接使用ts。ts虽然写的时候麻烦了点，但是真的香。 如果不知道怎么搭建vue3的ts项目，可参考我的上一篇文章：Vite4.3+Typescript+Vue3+Pinia 最新搭建企业级前端项目
ref 传入一个泛型参数 值 ref
jsconst initCode = ref(&amp;lsquo;200&amp;rsquo;); //默认推导出string类型
//或者手动定义更复杂的类型 const initCode = ref&amp;lt;string | number&amp;gt;(&amp;lsquo;200&amp;rsquo;);
模板 ref
js
组件 ref
js 如果子组件使用，默认是全关闭的，子组件需使用defineExpose定义父组件能访问的属性 2. reactive
定义接口
新建src/types/user.ts（在types文件夹下新建user.ts） jsexport interface User { name: string; age: number; }
使用
js import { reactive } from &amp;lsquo;vue&amp;rsquo;; import type { User } from &amp;lsquo;@/types/user&amp;rsquo;;
//reactive 会隐式地从它的参数中推导类型 //也可以使用接口直接给变量定义类型 const user: User = reactive({ name: &amp;lsquo;zhangsan&amp;rsquo;, age: 20, }); 提示：不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同 3.</description>
    </item>
    
    <item>
      <title>Go for 循环踩坑记录</title>
      <link>https://aurorawxm.github.io/posts/go-for-%E5%BE%AA%E7%8E%AF%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 09 May 2023 05:47:00 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/go-for-%E5%BE%AA%E7%8E%AF%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</guid>
      <description>案例一：取地址符 在 Go 语言中，我们写 for 语句时有时会出现运行和猜想的结果不一致。例如以下第一个案例的代码：
var all []*Item for _, item := range items { all = append(all, &amp;amp;item) } 这段代码有问题吗？变量 all 内的 item 变量，存储进去的是什么？ 是每次循环的 item 值吗？ 实际上在 for 循环时，每次存入变量 all 的都是相同的 item，也就是最后一个循环的 item 值。 这是 Go 面试里经常出现的题目，结合 goroutine 更风骚，毕竟还会存在乱序输出等问题。 如果你想解决这个问题，就需要把程序改写成如下：
var all []*Item for _, item := range items { item := item all = append(all, &amp;amp;item) } 要重新声明一个 item 变量把 for 循环的 item 变量给存储下来再追加进去。
案例二：闭包函数 接下来是第二个案例的代码：</description>
    </item>
    
    <item>
      <title>Go 语言中的奇妙用途</title>
      <link>https://aurorawxm.github.io/posts/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/</link>
      <pubDate>Mon, 08 May 2023 14:55:40 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A5%87%E5%A6%99%E7%94%A8%E9%80%94/</guid>
      <description>细说空结构体：Go 语言中的奇妙用途 在 Go 语言中，我们可以定义空结构体（empty struct），即没有任何成员变量的结构体，使用关键字 struct{} 来表示。这种结构体似乎没有任何用处，但实际上它在 Go 语言中的应用非常广泛，本文将从多个方面介绍空结构体的使用，让大家更好地理解它的作用。
1. 空结构体的定义和初始化 空结构体是指不包含任何字段的结构体。在 Golang 中，可以使用 struct{} 来定义一个空结构体。下面是一个简单的示例：
package main import &amp;#34;fmt&amp;#34; func main() { var s struct{} fmt.Printf(&amp;#34;%#v\n&amp;#34;, s) // 输出: struct {}{} } 在这个示例中，我们定义了一个名为s的变量，并将其初始化为一个空结构体。然后我们使用 fmt.Printf 将这个空结构体打印出来。注意，在打印时使用了 %#v 占位符，这个占位符可以将变量以 Go 语法格式输出。
输出结果是 struct {}{}，这表示 s 是一个空结构体，不包含任何字段。需要注意的是，空结构体变量实际上不占用任何内存空间，也就是说，它的大小是 0 字节。
2. 空结构体的大小和内存占用 正如上面提到的，空结构体的大小是 0 字节。这意味着它不占用任何内存空间。这一点可以通过使用 unsafe.Sizeof 函数来验证：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { var s struct{} fmt.Printf(&amp;#34;Size of struct{}: %v\n&amp;#34;, unsafe.</description>
    </item>
    
    <item>
      <title>Linux 进程调度详解</title>
      <link>https://aurorawxm.github.io/posts/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 08 May 2023 14:43:20 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. PCB 进程控制器 task_struct 对于 Linux 操作系统而言，每一个进程都对应一个 task_struct 结构体（Linux 中的线程也是由 task_struct 控制的，本文主要讨论进程调动的内容，就不展开说明了，在内存管理章节会介绍）。 在 task_struct 中维护了进程的 PID，进程状态以及堆栈信息等进程的几乎所有信息。 我们常常提到的“僵尸进程”，就是进程的堆栈信息被回收了，但是其 task_struct 却依旧存活在操作系统中。 “僵尸进程”往往是因为父进程处理子进程的销毁信号错误导致的。也是因为 task_struct 留存在操作系统中，所以“僵尸进程”是会消耗操作系统资源的。 与“僵尸进程”常常一起提及的是“孤儿进程”，“孤儿进程”是父进程先于子进程销毁导致的，不过“孤儿进程”会进行“寻找养父”的过程，先找“亲生父亲”的进程组中的兄弟进程，找不到的话就会认“0”号进程为父亲，所以“孤儿进程”的销毁并不会受阻，不会消耗操作系统过多的资源。
2. 进程调度算法 Linux 标准内核有两类调度类：CFS 调度算法的默认调度类和实时调度类。下面我们分类来讨论这两种不同的调度算法。
2.1 完全公平调度算法 CFS 一句话总结，CFS 会根据权重为各进程尽量“公平”的分配时间片。虽然叫做完全公平，但 CFS 算法并不是完全相同的未每个进程分配同样的时间片来运行，导致其不公平的原因有以下两点： CFS 是根据权重为每个进程分配时间片的（体现在其具体实现的红黑树上就是vruntime）。 为了避免进程的过度频繁切换，时间片的分配有一个最小值。 CFS 算法的底层实现是靠维护一棵进程vruntime的红黑树实现的，每一次选取vruntime最小的进程占据CPU。 下面分析一下 CFS 调度程序是如何工作的。假设有两个任务，它们具有相同的友好值。一个任务是 I/O 密集型而另一个为 CPU 密集型。通常，I/O 密集型任务在运行很短时间后就会阻塞以便等待更多的 I/O；而 CPU 密集型任务只要有在处理器上运行的机会，就会用完它的时间片。 因此，I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。
2.2 实时进程调度算法 Linux 底层实现了SCHED_FIFO 或 SCHED_RR 两种实时进程调度策略。 SCHED_FIFO 先到先服务，所有进程排队，先到的进程先执行，执行完到下一个进程。 SCHED_RR 时间片轮转，所有进程排队，但是一次只能领取一定的时间片，如果时间片用完，进程任务还没执行完，就会到队尾排队。</description>
    </item>
    
    <item>
      <title>10. Maps</title>
      <link>https://aurorawxm.github.io/posts/10.-maps/</link>
      <pubDate>Sat, 06 May 2023 06:08:14 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/10.-maps/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func main() { s := make([]string, 3) fmt.Println(&amp;#34;emp:&amp;#34;, s) s[0] = &amp;#34;a&amp;#34; s[1] = &amp;#34;b&amp;#34; s[2] = &amp;#34;c&amp;#34; fmt.Println(&amp;#34;set:&amp;#34;, s) fmt.Println(&amp;#34;get:&amp;#34;, s[2]) fmt.Println(&amp;#34;len:&amp;#34;, len(s)) s = append(s, &amp;#34;d&amp;#34;) s = append(s, &amp;#34;e&amp;#34;, &amp;#34;f&amp;#34;) fmt.Println(&amp;#34;apd:&amp;#34;, s) c := make([]string, len(s)) copy(c, s) fmt.Println(&amp;#34;cpy:&amp;#34;, c) l := s[2:5] fmt.Println(&amp;#34;sl1:&amp;#34;, l) l = s[:5] fmt.Println(&amp;#34;sl2:&amp;#34;, l) l = s[2:] fmt.Println(&amp;#34;sl3:&amp;#34;, l) t := []string{&amp;#34;g&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;i&amp;#34;} fmt.Println(&amp;#34;dcl:&amp;#34;, t) twoD := make([][]int, 3) for i := 0; i &amp;lt; 3; i++ { innerLen := i + 1 twoD[i] = make([]int, innerLen) for j := 0; j &amp;lt; innerLen; j++ { twoD[i][j] = i + j } } fmt.</description>
    </item>
    
    <item>
      <title>09. Slices</title>
      <link>https://aurorawxm.github.io/posts/09.-slices/</link>
      <pubDate>Sat, 06 May 2023 06:07:50 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/09.-slices/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func main() { s := make([]string, 3) fmt.Println(&amp;#34;emp:&amp;#34;, s) s[0] = &amp;#34;a&amp;#34; s[1] = &amp;#34;b&amp;#34; s[2] = &amp;#34;c&amp;#34; fmt.Println(&amp;#34;set:&amp;#34;, s) fmt.Println(&amp;#34;get:&amp;#34;, s[2]) fmt.Println(&amp;#34;len:&amp;#34;, len(s)) s = append(s, &amp;#34;d&amp;#34;) s = append(s, &amp;#34;e&amp;#34;, &amp;#34;f&amp;#34;) fmt.Println(&amp;#34;apd:&amp;#34;, s) c := make([]string, len(s)) copy(c, s) fmt.Println(&amp;#34;cpy:&amp;#34;, c) l := s[2:5] fmt.Println(&amp;#34;sl1:&amp;#34;, l) l = s[:5] fmt.Println(&amp;#34;sl2:&amp;#34;, l) l = s[2:] fmt.Println(&amp;#34;sl3:&amp;#34;, l) t := []string{&amp;#34;g&amp;#34;, &amp;#34;h&amp;#34;, &amp;#34;i&amp;#34;} fmt.Println(&amp;#34;dcl:&amp;#34;, t) twoD := make([][]int, 3) for i := 0; i &amp;lt; 3; i++ { innerLen := i + 1 twoD[i] = make([]int, innerLen) for j := 0; j &amp;lt; innerLen; j++ { twoD[i][j] = i + j } } fmt.</description>
    </item>
    
    <item>
      <title>08. Arrays</title>
      <link>https://aurorawxm.github.io/posts/08.-arrays/</link>
      <pubDate>Sat, 06 May 2023 06:07:25 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/08.-arrays/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { i := 2 fmt.Print(&amp;#34;Write &amp;#34;, i, &amp;#34; as &amp;#34;) switch i { case 1: fmt.Println(&amp;#34;one&amp;#34;) case 2: fmt.Println(&amp;#34;two&amp;#34;) case 3: fmt.Println(&amp;#34;three&amp;#34;) } switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(&amp;#34;It&amp;#39;s the weekend&amp;#34;) default: fmt.Println(&amp;#34;It&amp;#39;s a weekday&amp;#34;) } t := time.Now() switch { case t.Hour() &amp;lt; 12: fmt.Println(&amp;#34;It&amp;#39;s before noon&amp;#34;) default: fmt.Println(&amp;#34;It&amp;#39;s after noon&amp;#34;) } whatAmI := func(i interface{}) { switch t := i.</description>
    </item>
    
    <item>
      <title>07. Switch</title>
      <link>https://aurorawxm.github.io/posts/07.-switch/</link>
      <pubDate>Sat, 06 May 2023 06:06:57 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/07.-switch/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { i := 2 fmt.Print(&amp;#34;Write &amp;#34;, i, &amp;#34; as &amp;#34;) switch i { case 1: fmt.Println(&amp;#34;one&amp;#34;) case 2: fmt.Println(&amp;#34;two&amp;#34;) case 3: fmt.Println(&amp;#34;three&amp;#34;) } switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(&amp;#34;It&amp;#39;s the weekend&amp;#34;) default: fmt.Println(&amp;#34;It&amp;#39;s a weekday&amp;#34;) } t := time.Now() switch { case t.Hour() &amp;lt; 12: fmt.Println(&amp;#34;It&amp;#39;s before noon&amp;#34;) default: fmt.Println(&amp;#34;It&amp;#39;s after noon&amp;#34;) } whatAmI := func(i interface{}) { switch t := i.</description>
    </item>
    
    <item>
      <title>06.If_Else</title>
      <link>https://aurorawxm.github.io/posts/06.-if_else/</link>
      <pubDate>Sat, 06 May 2023 06:06:11 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/06.-if_else/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func main() { if 7%2 == 0 { fmt.Println(&amp;#34;7 is even&amp;#34;) } else { fmt.Println(&amp;#34;7 is odd&amp;#34;) } if 8%4 == 0 { fmt.Println(&amp;#34;8 is divisible by 4&amp;#34;) } if num := 9; num &amp;lt; 0 { fmt.Println(num, &amp;#34;is negative&amp;#34;) } else if num &amp;lt; 10 { fmt.Println(num, &amp;#34;has 1 digit&amp;#34;) } else { fmt.Println(num, &amp;#34;has multiple digits&amp;#34;) } } </description>
    </item>
    
    <item>
      <title>05. for</title>
      <link>https://aurorawxm.github.io/posts/05.-for/</link>
      <pubDate>Sat, 06 May 2023 06:05:30 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/05.-for/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func main() { i := 1 for i &amp;lt;= 3 { fmt.Println(i) i = i + 1 } for j := 7; j &amp;lt;= 9; j++ { fmt.Println(j) } for { fmt.Println(&amp;#34;loop&amp;#34;) break } for n := 0; n &amp;lt;= 5; n++ { if n%2 == 0 { continue } fmt.Println(n) } } </description>
    </item>
    
    <item>
      <title>04. Constants</title>
      <link>https://aurorawxm.github.io/posts/04.-constants/</link>
      <pubDate>Sat, 06 May 2023 06:03:54 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/04.-constants/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) const s string = &amp;#34;constant&amp;#34; func main() { fmt.Println(s) const n = 500000000 const d = 3e20 / n fmt.Println(d) fmt.Println(int64(d)) fmt.Println(math.Sin(n)) } </description>
    </item>
    
    <item>
      <title>03. variables</title>
      <link>https://aurorawxm.github.io/posts/03.-variables/</link>
      <pubDate>Sat, 06 May 2023 06:03:25 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/03.-variables/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func main() { var a = &amp;#34;initial&amp;#34; fmt.Println(a) var b, c int = 1, 2 fmt.Println(b, c) var d = true fmt.Println(d) var e int fmt.Println(e) f := &amp;#34;apple&amp;#34; fmt.Println(f) } </description>
    </item>
    
    <item>
      <title>02. values.md</title>
      <link>https://aurorawxm.github.io/posts/02.-values/</link>
      <pubDate>Sat, 06 May 2023 06:02:49 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/02.-values/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;go&amp;#34; + &amp;#34;lang&amp;#34;) fmt.Println(&amp;#34;1+1 =&amp;#34;, 1+1) fmt.Println(&amp;#34;7.0/3.0 =&amp;#34;, 7.0/3.0) fmt.Println(true &amp;amp;&amp;amp; false) fmt.Println(true || false) fmt.Println(!true) } </description>
    </item>
    
    <item>
      <title>01. hello world</title>
      <link>https://aurorawxm.github.io/posts/01.-hello-world/</link>
      <pubDate>Fri, 05 May 2023 07:03:48 +0000</pubDate>
      
      <guid>https://aurorawxm.github.io/posts/01.-hello-world/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;hello world&amp;#34;) } </description>
    </item>
    
  </channel>
</rss>
